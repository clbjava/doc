----------------------------------------------------------------------------------------------------------------------------------------
成员变量、本地（局部）变量、类成员变量

成员变量、类成员变量->存储在堆

本地（局部）变量：方法参数、方法体里面定义的变量->引用存储在栈？


1、局部变量表内容越多，栈帧越大，栈深度越小。
2、栈帧：栈调用过程中存储的调用记录。->同样栈大小，执行过程中栈栈越大，栈深度就越小。
查看CPU信息（型号）
----------------------------------------------------------------------------------------------------------------------------------------
# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 
      8  Intel(R) Xeon(R) CPU            E5410   @ 2.33GHz 
(看到有8个逻辑CPU, 也知道了CPU型号) 

# cat /proc/cpuinfo | grep physical | uniq -c 
      4 physical id      : 0 
      4 physical id      : 1 
(说明实际上是两颗4核的CPU) 

# getconf LONG_BIT 
   32 
(说明当前CPU运行在32bit模式下, 但不代表CPU不支持64bit) 

# cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 
   8 
(结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit) 


再完整看cpu详细信息, 不过大部分我们都不关心而已. 
# dmidecode | grep 'Processor Information' 

查看内 存信息 
# cat /proc/meminfo 

# uname -a 
Linux euis1 2.6.9-55.ELsmp #1 SMP Fri Apr 20 17:03:35 EDT 2007 i686 i686 i386 GNU/Linux 
(查看当前操作系统内核信息) 

# cat /etc/issue | grep Linux 
Red Hat Enterprise Linux AS release 4 (Nahant Update 5) 
(查看当前操作系统发行版信息) 

查看机器型号 
# dmidecode | grep "Product Name"  

查看网卡信息 
# dmesg | grep -i eth
----------------------------------------------------------------------------------------------------------------------------------------
->查看当前系统运行情况（cpu、内存）-> 分析是内存原因、还是线程原因 -> 内存原因检查堆 ->解决问题->线程原因 检查线程栈

linux:
uptime :该命令将显示目前服务器持续运行的时间，以及负载情况。

top:查看当前系统的CPU/内存以及相关的进程状态

vmstat：可以查看系统CPU/内存、swap、io等情况

vmstat 1 4
上面的命令每隔1秒采样一次，一共采样四次。CPU占用率很高，
上下文切换频繁，说明系统有线程正在频繁切换，这可能是你的程序开启了大量的线程存在资源竞争的情况。
另外swap也是值得关注的指标，如果swpd过高则可能系统能使用的物理内存不足，不得不使用交换区内存，
还有一个例外就是某些程序优先使用swap，导致swap飙升，而物理内存还有很多空余，这些情况是需要注意的。
----------------------------------------------------------------------------------------------------------------------------------------
JDK自带有用的工具：jps、jstat、jmap、jstack。

jps:查看java程序的进程号，找到进程ID，可以通过top -p ID 直接查看进程状态。

jstat：用于输出java程序内存使用情况，包括新生代、老年代、元数据区容量、垃圾回收情况。

gc实时执行情况
命令参数说明：
Options，一般使用 -gcutil 或  -gc 查看gc 情况
pid，当前运行的 java进程号 
interval，间隔时间，单位为秒或者毫秒 
count，打印次数，如果缺省则打印无数次
 
Options 参数如下：
-gc：统计 jdk gc时 heap信息，以使用空间字节数表示
-gcutil：统计 gc时， heap情况，以使用空间的百分比表示
-class：统计 class loader行为信息
-compile：统计编译行为信息
-gccapacity：统计不同 generations（新生代，老年代，持久代）的 heap容量情况
-gccause：统计引起 gc的事件
-gcnew：统计 gc时，新生代的情况
-gcnewcapacity：统计 gc时，新生代 heap容量
-gcold：统计 gc时，老年代的情况
-gcoldcapacity：统计 gc时，老年代 heap容量
-gcpermcapacity：统计 gc时， permanent区 heap容量

jstat -gcutil PID 2000 20
说明：上述命令输出进程ID为3618的内存使用情况（每2000毫秒输出一次，一共输出20次）
S0：幸存1区当前使用比例
S1：幸存2区当前使用比例
E：伊甸园区使用比例
O：老年代使用比例
M：元数据区使用比例
CCS：压缩使用比例
YGC：年轻代垃圾回收次数
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间

jmap：用于输出java程序中内存对象的情况，包括有哪些对象，对象的数量。

jmap -histo 3618
上述命令打印出进程ID为3618的内存情况。但我们常用的方式是将指定进程的内存heap输出到外部文件，
再由专门的heap分析工具进行分析,例如mat（Memory Analysis Tool），所以我们常用的命令是：

jmap -dump:live,format=b,file=heap.hprof 3618
将heap.hprof传输出来到window电脑上使用mat工具分析

jstack：用户输出java程序线程栈的情况，常用于定位因为某些线程问题造成的故障或性能问题。

jstack 3618 > jstack.out
上述命令将进程ID为3618的栈信息输出到外部文件，便于传输到windows电脑上进行分析。

自带监控图形界面
Jconsole 
Jvisualvm  

statck
start-> new ->runable->runing->blocked->dead

----------------------------------------------------------------------------------------------------------------------------------------
2018-12-10 Linux:

1、命令查看CPU、内存等使用情况：top

2、命令查看进程的线程情况：ps -mp pid -o THREAD,tid,time

3、命令将线程id转换为16进制：printf "%x\n" 6766（tid）

4、命令查看线程堆栈信息GC:jstack pid |grep tid

5、命令jstat查看进程内存状况：jstat -gcutil

6、命令jstack 和 jmap 分析进程堆栈和内存状况：
   （1）、命令: jmap [option] vmid 
   jmap -dump:format=b,file=dump.bin 6764
   （2）、命令: jstack [option] vmid 
   jstack -l 6764 >> jstack.out









